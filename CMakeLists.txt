cmake_minimum_required (VERSION 3.6)
project (dimcli)
set_property(GLOBAL PROPERTY USE_FOLDERS ON)
set(CMAKE_CONFIGURATION_TYPES Debug RelWithDebInfo)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG bin)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO bin)

include_directories(include)
# add_compile_options(/std:c++latest)

# Compare the new contents with the existing file, if it exists and is the 
# same we don't want to trigger a make by changing its timestamp.
function(update_file path content)
    set(old_content "")
    if(EXISTS "${path}")
        file(READ "${path}" old_content)
    endif()
    if(NOT old_content STREQUAL content)
        file(WRITE "${path}" "${content}")
    endif()
endfunction(update_file)

# Creates a file called CMakeDeps.cmake next to your CMakeLists.txt with
# the list of dependencies in it - this file should be treated as part of 
# CMakeLists.txt (source controlled, etc.).
function(update_deps_file)
    set(deps_file "CMakeDeps.cmake")
    # Normalize the list so it's the same on every machine
    foreach(dep ${ARGV})
        get_filename_component(dep "${dep}" ABSOLUTE)
        file(RELATIVE_PATH rel_dep ${CMAKE_CURRENT_SOURCE_DIR} ${dep})
        list(APPEND rel_deps ${rel_dep})
    endforeach(dep)
    list(REMOVE_DUPLICATES rel_deps)
    list(SORT rel_deps)
    # Build the content
    set(content "# generated by make process\n")
    foreach(dep IN LISTS rel_deps)
        string(APPEND content "# ${dep}\n")
    endforeach(dep)
    # Update the deps file
    update_file("${deps_file}" "${content}")
    # Include the file so it's tracked as a generation dependency we don't
    # need the content.
    include(${deps_file})
endfunction(update_deps_file)

function(write_user_file prjname)
    set(user_file "${CMAKE_CURRENT_BINARY_DIR}/${prjname}.vcxproj.user")
    file(WRITE ${user_file} [=[
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" 
        xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
]=])
    foreach(cfgname ${CMAKE_CONFIGURATION_TYPES})
        file(APPEND ${user_file} [=[
    <PropertyGroup Condition="'$(Configuration)|$(Platform)'==']=] "${cfgname}" [=[|x64'">
        <LocalDebuggerWorkingDirectory>$(TargetDir)</LocalDebuggerWorkingDirectory>
        <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    </PropertyGroup>
]=])
    endforeach(cfgname)
    file(APPEND ${user_file} [=[
</Project>
]=])
endfunction(write_user_file)

file(GLOB meta_sources LIST_DIRECTORIES false 
    .clang-format
    appveyor.yml
    LICENSE
    README.md
    docs/*)
update_deps_file(${meta_sources})
add_custom_target("_meta" SOURCES ${meta_sources})
source_group("docs" REGULAR_EXPRESSION "docs/.*")

add_subdirectory(src)
add_subdirectory(test)

# The solution file isn't generated until after this script finishes, 
# which means that:
#   - it might not exist (if this is the first run)
#   - you need to run cmake twice to ensure any new solution was copied
set(sln_binpath ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.sln)
if(EXISTS ${sln_binpath})
    # Load solution file from bin-dir and change the relative references to 
    # project files so that the in memory copy is as if it had been built in 
    # the source dir.
    file(RELATIVE_PATH prefix 
        ${CMAKE_CURRENT_SOURCE_DIR} 
        ${CMAKE_CURRENT_BINARY_DIR})
    file(READ ${sln_binpath} sln_content)
    string(REGEX REPLACE 
        "\"([^\"]+).vcxproj\""
        "\"${prefix}/\\1.vcxproj\"" 
        sln_content
        "${sln_content}")

    # Compare the updated contents with the existing source path sln, if it
    # exists and is the same we don't want to disturb VS by touching it.
    set(sln_srcpath ${CMAKE_CURRENT_SOURCE_DIR}/${PROJECT_NAME}.sln)
    update_file("${sln_srcpath}" "${sln_content}")
endif()
